<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Ray Tracer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root { font-family: 'Inter', sans-serif; }
        .canvas-container {
            width: 100%;
            max-width: 640px;
            margin: auto;
            aspect-ratio: 16 / 9;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1);
        }
        #tracerCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl sm:text-4xl font-bold text-gray-800 mb-6 text-center">Software Ray Tracer</h1>
        <p class="text-center text-gray-600 mb-8">Click "Begin Ray Trace"</p>

        <div class="canvas-container rounded-xl overflow-hidden mb-8 bg-gray-900 border-4 border-gray-700">
            <canvas id="tracerCanvas" width="640" height="360"></canvas>
        </div>

        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
            
            <div class="flex flex-col md:flex-row md:space-x-8 space-y-4 md:space-y-0">
                
                <div class="flex-1">
                    <label for="maxBounces" class="block text-sm font-medium text-gray-700 mb-1">Max Reflection/Refraction Bounces</label>
                    <input type="number" id="maxBounces" value="5" min="0" max="10" step="1"
                        class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <p class="text-xs text-gray-500 mt-1">Controls reflection/refraction depth.</p>
                </div>

                <div class="flex-1">
                    <label for="samplesPerPixel" class="block text-sm font-medium text-gray-700 mb-1">Samples per Pixel (Anti-aliasing)</label>
                    <input type="number" id="samplesPerPixel" value="2" min="1" max="10" step="1"
                        class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <p class="text-xs text-gray-500 mt-1">Controls anti-aliasing quality.</p>
                </div>
            </div>

            <div class="mt-6 flex flex-col sm:flex-row items-center justify-between space-y-4 sm:space-y-0">
                <div class="flex space-x-4">
                    <button id="renderButton"
                        class="w-full sm:w-auto px-6 py-3 bg-blue-600 text-white font-semibold rounded-xl shadow-md hover:bg-blue-700 transition duration-150 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed">
                        Begin Ray Trace
                    </button>
                    <button id="stopButton" disabled
                        class="w-full sm:w-auto px-6 py-3 bg-red-500 text-white font-semibold rounded-xl shadow-md hover:bg-red-600 transition duration-150 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed">
                        Stop Render
                    </button>
                </div>
                <div id="statusMessage" class="text-sm text-gray-600 font-medium">Ready.</div>
            </div>
        </div>
        
        <div id="messageBox" class="mt-6 p-4 text-sm text-yellow-800 bg-yellow-100 rounded-lg hidden" role="alert">
            <span class="font-medium">Error/Info:</span> <span id="messageText"></span>
        </div>
    </div>

    <script type="text/javascript">
        const NUM_WORKERS = navigator.hardwareConcurrency || 4; 

        let light = { position: [0, 50, -1000], color: [255, 255, 200], intensity: 1.5 };
        let AMBIENT_FACTOR = 50; 
        let lightDirection = [0, 0, 0]; 
        
        const cameraPos = [0, 0, 0];

        const lerp = (a, b, t) => a + (b - a) * t;
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const v3 = (x, y, z) => [x, y, z]; 
        
        function computeBoundingBox(sphere) {
            const r = sphere.radius;
            const c = sphere.center;
            return {
                min: [c[0] - r, c[1] - r, c[2] - r],
                max: [c[0] + r, c[1] + r, c[2] + r],
            };
        }

        const scene = [
            { type: 'sphere', center: [-2.5, -0.5, -15], radius: 1.5, color: [255, 255, 255], reflectivity: 0.1, specular: 0.8, isLight: false, isTransparent: true, refractiveIndex: 1.5, shininess: 100.0 },
            { type: 'sphere', center: [2.5, -0.5, -10], radius: 1.0, color: [50, 50, 255], reflectivity: 0.1, specular: 0.9, isLight: false, isTransparent: false, refractiveIndex: 1.0, shininess: 64.0 },
            { type: 'sphere', center: [0, 1.5, -18], radius: 1.0, color: [50, 255, 50], reflectivity: 0.5, specular: 0.5, isLight: false, isTransparent: false, refractiveIndex: 1.0, shininess: 32.0 },
            { type: 'sphere', center: [1.0, -1.5, -13], radius: 0.5, color: [255, 150, 50], reflectivity: 0.1, specular: 0.1, isLight: false, isTransparent: false, refractiveIndex: 1.0, shininess: 16.0 },
        ].map(obj => {
            if (obj.type === 'sphere') {
                obj.box = computeBoundingBox(obj);
            }
            return obj;
        });

        const canvas = document.getElementById('tracerCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const width = canvas.width;
        const height = canvas.height;
        const TOTAL_PIXELS = width * height; 
        
        const renderButton = document.getElementById('renderButton');
        const stopButton = document.getElementById('stopButton');
        const statusMessage = document.getElementById('statusMessage');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const maxBouncesInput = document.getElementById('maxBounces');
        const samplesPerPixelInput = document.getElementById('samplesPerPixel');

        let workers = [];
        let workerProgress = {}; 
        let isRendering = false;

        const fov = Math.tan((Math.PI / 180) * 45 / 2); 
        const aspectRatio = width / height;

        function setupFixedSceneLighting() {
            const fixedTimeValue = 50; 
            const timeRatio = fixedTimeValue / 100; 

            const sunCycle = Math.sin(timeRatio * Math.PI); 
            const maxIntensity = 2.0;
            const minIntensity = 0.2; 
            light.intensity = lerp(minIntensity, maxIntensity, sunCycle);
            AMBIENT_FACTOR = lerp(10, 80, sunCycle); 
            
            const lightY = lerp(-10, 80, sunCycle);
            const lightX = lerp(-20, 20, timeRatio); 
            
            light.position = [lightX, lightY, -1000];
            
            const dirX = light.position[0] - 0;
            const dirY = light.position[1] - 0;
            const dirZ = light.position[2] - 0;
            const length = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ);
            lightDirection = [dirX / length, dirY / length, dirZ / length];

            const dayColor = [255, 255, 200];   
            light.color = dayColor; 
        }

        const workerScriptContentLines = [
            'const v3 = (x, y, z) => [x, y, z];',
            'const sub = (a, b) => v3(a[0] - b[0], a[1] - b[1], a[2] - b[2]);',
            'const dot = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2];',
            'const scale = (a, s) => v3(a[0] * s, a[1] * s, a[2] * s);',
            'const add = (a, b) => v3(a[0] + b[0], a[1] + b[1], a[2] + b[2]);',
            'const normalize = (v) => {',
            '    const len = Math.sqrt(dot(v, v));',
            '    return len > 1e-6 ? scale(v, 1 / len) : v3(0, 0, 0);',
            '};',
            'const clamp = (v, min, max) => Math.max(min, Math.min(max, v));',
            'const lerp = (a, b, t) => a + (b - a) * t;',
            'const length = (v) => Math.sqrt(dot(v, v));',
            '',
            'function reflect(rayDir, normal) {',
            '    return sub(rayDir, scale(normal, 2 * dot(rayDir, normal)));',
            '}',
            '',
            'function refract(rayDir, normal, n1, n2) {',
            '    const n = n1 / n2;',
            '    const cosI = clamp(dot(scale(rayDir, -1), normal), -1, 1);',
            '    const sinT2 = n * n * (1.0 - cosI * cosI);',
            '    ',
            '    if (sinT2 >= 1.0) {',
            '        return null;',
            '    }',
            '    ',
            '    const cosT = Math.sqrt(1.0 - sinT2);',
            '    const refractedDir = add(scale(rayDir, n), scale(normal, (n * cosI - cosT)));',
            '    return normalize(refractedDir);',
            '}',
            '',
            'function intersectAABB(rayOrigin, rayDir, box) {',
            '    let tmin = -Infinity;',
            '    let tmax = Infinity;',
            '',
            '    for (let i = 0; i < 3; i++) {',
            '        const invD = 1.0 / rayDir[i];',
            '        let t0 = (box.min[i] - rayOrigin[i]) * invD;',
            '        let t1 = (box.max[i] - rayOrigin[i]) * invD;',
            '',
            '        if (invD < 0.0) {',
            '            [t0, t1] = [t1, t0];',
            '        }',
            '',
            '        tmin = Math.max(t0, tmin);',
            '        tmax = Math.min(t1, tmax);',
            '',
            '        if (tmax <= tmin) return false;',
            '    }',
            '    return tmax > 0.001;',
            '}',
            '',
            'function intersectSphere(rayOrigin, rayDir, sphere) {',
            '    const oc = sub(rayOrigin, sphere.center);',
            '    const a = dot(rayDir, rayDir);',
            '    const b = 2.0 * dot(oc, rayDir);',
            '    const c = dot(oc, oc) - sphere.radius * sphere.radius;',
            '    const discriminant = b * b - 4 * a * c;',
            '',
            '    if (discriminant < 0) return null;',
            '',
            '    const sqrtDiscriminant = Math.sqrt(discriminant);',
            '    const t1 = (-b - sqrtDiscriminant) / (2.0 * a);',
            '    const t2 = (-b + sqrtDiscriminant) / (2.0 * a);',
            '',
            '    let t = t1 > 0.001 ? t1 : t2;',
            '',
            '    if (t > 0.001) {',
            '        const hitPoint = add(rayOrigin, scale(rayDir, t));',
            '        const normal = normalize(sub(hitPoint, sphere.center));',
            '        return { t, hitPoint, normal, object: sphere };',
            '    }',
            '    return null;',
            '}',
            '',
            'function intersectPlane(rayOrigin, rayDir) {',
            '    const normal = v3(0, 1, 0);',
            '    const distance = -2;',
            '',
            '    const denom = dot(normal, rayDir);',
            '    if (Math.abs(denom) < 1e-6) return null;',
            '',
            '    const t = -(dot(normal, rayOrigin) - distance) / denom;',
            '',
            '    if (t > 0.001) {',
            '        const hitPoint = add(rayOrigin, scale(rayDir, t));',
            '        const checkSize = 2.0;',
            '        const xCheck = Math.floor(hitPoint[0] / checkSize) % 2;',
            '        const zCheck = Math.floor(hitPoint[2] / checkSize) % 2;',
            '        const isOdd = (xCheck + zCheck) % 2 === 0;',
            '        const color = isOdd ? v3(100, 100, 100) : v3(40, 40, 40);',
            '        ',
            '        return {',
            '            t, hitPoint, normal,',
            '            object: {',
            '                color: color,',
            '                reflectivity: 0.3,',
            '                specular: 0.1,',
            '                shininess: 1.0,',
            '                isLight: false,',
            '                isTransparent: false,',
            '                refractiveIndex: 1.0',
            '            }',
            '        };',
            '    }',
            '    return null;',
            '}',
            '',
            'function findClosestHit(rayOrigin, rayDir, scene) {',
            '    let closestHit = null;',
            '    let minT = Infinity;',
            '',
            '    for (const object of scene) {',
            '        let hit;',
            '        if (object.type === \'sphere\') {',
            '            if (object.box && !intersectAABB(rayOrigin, rayDir, object.box)) {',
            '                continue;',
            '            }',
            '            hit = intersectSphere(rayOrigin, rayDir, object);',
            '        }',
            '        ',
            '        if (hit && hit.t < minT) {',
            '            minT = hit.t;',
            '            closestHit = hit;',
            '        }',
            '    }',
            '',
            '    const planeHit = intersectPlane(rayOrigin, rayDir);',
            '    if (planeHit && planeHit.t < minT) {',
            '        minT = planeHit.t;',
            '        closestHit = planeHit;',
            '    }',
            '',
            '    return closestHit;',
            '}',
            '',
            'function calculateLocalColor(hit, object, light, AMBIENT_FACTOR, lightDirection, scene, rayDir) {',
            '    const lightVec = sub(light.position, hit.hitPoint);',
            '    const distToLight = length(lightVec);',
            '    const lightDir = scale(lightVec, 1 / distToLight);',
            '    ',
            '    const shadowHit = findClosestHit(add(hit.hitPoint, scale(hit.normal, 0.001)), lightDir, scene);',
            '    ',
            '    let shadowFactor = 1.0;',
            '    if (shadowHit && shadowHit.t < distToLight) {',
            '        shadowFactor = 0.0;',
            '    }',
            '',
            '    const diffuseIntensity = Math.max(0, dot(hit.normal, lightDir));',
            '    ',
            '    let specularColor = v3(0, 0, 0);',
            '    if (object.specular > 0 && shadowFactor > 0) {',
            '        const viewDir = scale(rayDir, -1);',
            '        ',
            '        const reflectedLightDir = normalize(sub(scale(hit.normal, 2 * dot(hit.normal, lightDir)), lightDir));',
            '',
            '        const specularIntensity = Math.pow(Math.max(0, dot(reflectedLightDir, viewDir)), object.shininess || 32.0);',
            '',
            '        const specFactor = specularIntensity * object.specular;',
            '        specularColor = v3(',
            '            light.color[0] * specFactor * light.intensity,',
            '            light.color[1] * specFactor * light.intensity,',
            '            light.color[2] * specFactor * light.intensity',
            '        );',
            '    }',
            '',
            '    const R_ambient = (AMBIENT_FACTOR * object.color[0]/255);',
            '    const G_ambient = (AMBIENT_FACTOR * object.color[1]/255);',
            '    const B_ambient = (AMBIENT_FACTOR * object.color[2]/255);',
            '    ',
            '    const R_diffuse = (object.color[0] * diffuseIntensity * light.intensity) * shadowFactor;',
            '    const G_diffuse = (object.color[1] * diffuseIntensity * light.intensity) * shadowFactor;',
            '    const B_diffuse = (object.color[2] * diffuseIntensity * light.intensity) * shadowFactor;',
            '',
            '    const R_final = R_diffuse + R_ambient + specularColor[0];',
            '    const G_final = G_diffuse + G_ambient + specularColor[1];',
            '    const B_final = B_diffuse + B_ambient + specularColor[2];',
            '',
            '    return v3(R_final, G_final, B_final);',
            '}',
            '',
            'function getSkyColor(rayDir, light, lightDirection) {',
            '    const baseR = 100, baseG = 150, baseB = 255;',
            '    const t_vertical = 0.5 * (rayDir[1] + 1.0);',
            '    ',
            '    let color = v3(',
            '        lerp(baseR * 0.5, baseR, t_vertical),',
            '        lerp(baseG * 0.5, baseG, t_vertical),',
            '        lerp(baseB * 0.5, baseB, t_vertical)',
            '    );',
            '',
            '    const alignment = dot(rayDir, lightDirection);',
            '    const beamFactor = Math.pow(alignment, 50.0) * light.intensity;',
            '    ',
            '    color[0] += light.color[0] * beamFactor / 255.0;',
            '    color[1] += light.color[1] * beamFactor / 255.0;',
            '    color[2] += light.color[2] * beamFactor / 255.0;',
            '',
            '    return color;',
            '}',
            '',
            'function traceRay(rayOrigin, rayDir, depth, maxDepth, n_in, light, AMBIENT_FACTOR, lightDirection, scene) {',
            '    if (depth >= maxDepth) {',
            '        return v3(0, 0, 0);',
            '    }',
            '    ',
            '    const hit = findClosestHit(rayOrigin, rayDir, scene);',
            '',
            '    if (!hit) {',
            '        return getSkyColor(rayDir, light, lightDirection);',
            '    }',
            '',
            '    const object = hit.object;',
            '',
            '    if (object.isLight) {',
            '        return object.color;',
            '    }',
            '',
            '    let localColor = calculateLocalColor(hit, object, light, AMBIENT_FACTOR, lightDirection, scene, rayDir);',
            '    ',
            '    let reflectionColor = v3(0, 0, 0);',
            '    let refractionColor = v3(0, 0, 0);',
            '',
            '    if (object.reflectivity > 0) {',
            '        const reflectedDir = reflect(rayDir, hit.normal);',
            '        const reflectionOrigin = add(hit.hitPoint, scale(hit.normal, 0.001));',
            '        reflectionColor = traceRay(reflectionOrigin, reflectedDir, depth + 1, maxDepth, n_in, light, AMBIENT_FACTOR, lightDirection, scene);',
            '    }',
            '',
            '    if (object.isTransparent) {',
            '        const cosI = dot(scale(rayDir, -1), hit.normal);',
            '        let normal = hit.normal;',
            '        let n1 = n_in;',
            '        let n2 = object.refractiveIndex;',
            '        ',
            '        if (cosI < 0) {',
            '            normal = scale(normal, -1);',
            '            [n1, n2] = [n2, n1];',
            '        }',
            '        ',
            '        const refractedDir = refract(rayDir, normal, n1, n2);',
            '        ',
            '        if (refractedDir) {',
            '            const refractionOrigin = add(hit.hitPoint, scale(normal, -0.001));',
            '            refractionColor = traceRay(refractionOrigin, refractedDir, depth + 1, maxDepth, n2, light, AMBIENT_FACTOR, lightDirection, scene);',
            '        } else {',
            '             object.reflectivity = 1.0; ',
            '             refractionColor = v3(0, 0, 0);',
            '        }',
            '        ',
            '        const transparentMix = 0.95;',
            '        localColor = scale(object.color, (1.0 - transparentMix) * (1.0 - object.reflectivity));',
            '        ',
            '        const R_final = clamp(localColor[0] + reflectionColor[0] * object.reflectivity + refractionColor[0] * transparentMix, 0, 255);',
            '        const G_final = clamp(localColor[1] + reflectionColor[1] * object.reflectivity + refractionColor[1] * transparentMix, 0, 255);',
            '        const B_final = clamp(localColor[2] + reflectionColor[2] * object.reflectivity + refractionColor[2] * transparentMix, 0, 255);',
            '        return v3(R_final, G_final, B_final);',
            '    }',
            '',
            '    const R = clamp(localColor[0] * (1.0 - object.reflectivity) + reflectionColor[0] * object.reflectivity, 0, 255);',
            '    const G = clamp(localColor[1] * (1.0 - object.reflectivity) + reflectionColor[1] * object.reflectivity, 0, 255);',
            '    const B = clamp(localColor[2] * (1.0 - object.reflectivity) + reflectionColor[2] * object.reflectivity, 0, 255);',
            '',
            '    return v3(R, G, B);',
            '}',
            '',
            'self.onmessage = function(e) {',
            '    const {',
            '        width, height, startRow, endRow, workerId,',
            '        maxBounces, samplesPerPixel,',
            '        scene, light, AMBIENT_FACTOR, lightDirection, cameraPos,',
            '        fov, aspectRatio',
            '    } = e.data;',
            '',
            '    const n_air = 1.0;',
            '    const stripHeight = endRow - startRow + 1;',
            '    const totalPixelsInStrip = width * stripHeight;',
            '    const progressReportInterval = Math.max(1, Math.floor(stripHeight / 10)); ',
            '    ',
            '    const pixelData = new Uint8ClampedArray(totalPixelsInStrip * 4);',
            '    let dataIndex = 0;',
            '    let currentStripRow = 0;',
            '',
            '    for (let y = startRow; y <= endRow; y++) {',
            '        for (let x = 0; x < width; x++) {',
            '            let finalColor = v3(0, 0, 0);',
            '',
            '            for (let s = 0; s < samplesPerPixel; s++) {',
            '                const u = (x + Math.random()) / width;',
            '                const v = (y + Math.random()) / height;',
            '',
            '                const xDir = (2 * u - 1) * aspectRatio * fov;',
            '                const yDir = (1 - 2 * v) * fov;',
            '                const zDir = -1;',
            '                ',
            '                const rayDir = normalize(v3(xDir, yDir, zDir));',
            '                ',
            '                const sampleColor = traceRay(cameraPos, rayDir, 0, maxBounces, n_air, light, AMBIENT_FACTOR, lightDirection, scene);',
            '                ',
            '                finalColor = add(finalColor, sampleColor);',
            '            }',
            '',
            '            finalColor = scale(finalColor, 1 / samplesPerPixel);',
            '            ',
            '            pixelData[dataIndex++] = clamp(finalColor[0], 0, 255);',
            '            pixelData[dataIndex++] = clamp(finalColor[1], 0, 255);',
            '            pixelData[dataIndex++] = clamp(finalColor[2], 0, 255);',
            '            pixelData[dataIndex++] = 255;',
            '        }',
            '        ',
            '        currentStripRow++;',
            '        if (currentStripRow % progressReportInterval === 0 && (currentStripRow * width) < totalPixelsInStrip) {',
            '            self.postMessage({ ',
            '                type: \'progress\', ',
            '                workerId, ',
            '                pixelsProcessed: currentStripRow * width ',
            '            });',
            '        }',
            '    }',
            '',
            '    self.postMessage({ ',
            '        type: \'complete\', ',
            '        pixelData, startRow, endRow, workerId, ',
            '        pixelsProcessed: totalPixelsInStrip',
            '    }, [pixelData.buffer]);',
            '};'
        ];
        const workerScriptContent = workerScriptContentLines.join('\n'); 

        function stopRender() {
            if (!isRendering) return;

            workers.forEach(worker => worker.terminate());
            workers = []; 
            workerProgress = {}; 

            isRendering = false;
            renderButton.disabled = false;
            stopButton.disabled = true;
            renderButton.textContent = 'Render Stopped! Restart Ray Trace';
            statusMessage.textContent = 'Rendering stopped by user.';
        }

        function updateProgress() {
            let totalPixelsRendered = 0;
            for (const id in workerProgress) {
                totalPixelsRendered += workerProgress[id];
            }

            const progress = Math.min(100, Math.floor((totalPixelsRendered / TOTAL_PIXELS) * 100));
            statusMessage.textContent = `Rendering: ${progress}% (${totalPixelsRendered.toLocaleString()} / ${TOTAL_PIXELS.toLocaleString()} pixels)`;

            if (totalPixelsRendered >= TOTAL_PIXELS && isRendering) {
                isRendering = false;
                renderButton.disabled = false;
                stopButton.disabled = true;
                renderButton.textContent = 'Begin Ray Trace';
                statusMessage.textContent = 'Ray trace finished';
            }
        }

        function startRender() {
            if (isRendering) return;
            
            const maxBounces = parseInt(maxBouncesInput.value, 10);
            const samplesPerPixel = parseInt(samplesPerPixelInput.value, 10);

            if (maxBounces < 0 || samplesPerPixel < 1) {
                showMessage('Please ensure Max Bounces is non-negative and Samples per Pixel is at least 1.', 'error');
                return;
            }

            setupFixedSceneLighting();
            
            isRendering = true;
            workerProgress = {}; 
            renderButton.disabled = true;
            stopButton.disabled = false;
            renderButton.textContent = 'Rendering...';
            statusMessage.textContent = 'Rendering: 0%';
            hideMessage();

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);

            if (workers.length === 0) {
                const blob = new Blob([workerScriptContent], { type: 'application/javascript' });
                const workerURL = URL.createObjectURL(blob);

                for (let i = 0; i < NUM_WORKERS; i++) {
                    const worker = new Worker(workerURL);
                    worker.onmessage = handleWorkerMessage;
                    workers.push(worker);
                }
            } else {
                 workers = [];
                 const blob = new Blob([workerScriptContent], { type: 'application/javascript' });
                 const workerURL = URL.createObjectURL(blob);
                 for (let i = 0; i < NUM_WORKERS; i++) {
                     const worker = new Worker(workerURL);
                     worker.onmessage = handleWorkerMessage;
                     workers.push(worker);
                 }
            }

            const rowsPerWorker = Math.ceil(height / NUM_WORKERS);
            
            for (let i = 0; i < NUM_WORKERS; i++) {
                const startRow = i * rowsPerWorker;
                const endRow = Math.min(startRow + rowsPerWorker, height) - 1;

                if (startRow > endRow) continue; 
                
                workerProgress[i] = 0;

                workers[i].postMessage({
                    width,
                    height,
                    startRow,
                    endRow,
                    workerId: i,
                    maxBounces,
                    samplesPerPixel,
                    scene,
                    light,
                    AMBIENT_FACTOR,
                    lightDirection,
                    cameraPos,
                    fov,
                    aspectRatio
                });
            }
        }

        function handleWorkerMessage(e) {
            const { type, workerId, pixelsProcessed } = e.data;
            
            if (type === 'progress') {
                workerProgress[workerId] = pixelsProcessed;
                updateProgress();

            } else if (type === 'complete') {
                const { pixelData, startRow, endRow } = e.data;
                
                const stripHeight = endRow - startRow + 1;
                const stripImageData = ctx.createImageData(width, stripHeight);

                stripImageData.data.set(pixelData);
                ctx.putImageData(stripImageData, 0, startRow);

                workerProgress[workerId] = pixelsProcessed;
                updateProgress();
            }
        }

        function showMessage(text, type) {
            messageText.textContent = text;
            messageBox.className = 'mt-6 p-4 text-sm rounded-lg';
            if (type === 'error') {
                messageBox.classList.add('text-red-800', 'bg-red-100');
            } else if (type === 'info') {
                messageBox.classList.add('text-blue-800', 'bg-blue-100');
            } else {
                 messageBox.classList.add('text-yellow-800', 'bg-yellow-100');
            }
            messageBox.classList.remove('hidden');
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        renderButton.addEventListener('click', startRender);
        stopButton.addEventListener('click', stopRender);

        setupFixedSceneLighting(); 
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);
        showMessage(`Ready! Using ${NUM_WORKERS} workers.`, 'info');
    </script>
</body>
</html>
