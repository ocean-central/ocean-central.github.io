<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Neon Wireframe FPS Trainer</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-touch-callout: none; /* iOS Safari */
            touch-action: none; /* Prevent browser zooming/scrolling */
            position: fixed; /* Fixes mobile viewport height issues */
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 2;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-size: 24px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .hud-bottom {
            padding: 20px;
            font-size: 18px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        #crosshair::before {
            top: 9px;
            left: 0;
            width: 20px;
            height: 2px;
        }

        #crosshair::after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 20px;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
            z-index: 20;
            cursor: pointer;
        }

        h1 {
            font-size: 4rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        p {
            font-size: 1.2rem;
            color: #aaaaaa;
            margin-bottom: 30px;
            text-align: center;
            padding: 0 20px;
        }

        .btn {
            padding: 15px 40px;
            border: 2px solid #00ffff;
            background: transparent;
            color: #00ffff;
            font-size: 1.5rem;
            font-family: inherit;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        .hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 2px solid #ff0055;
            width: 15px;
            height: 15px;
            opacity: 0;
            transition: opacity 0.12s ease;
            box-shadow: 0 0 10px #ff0055;
            pointer-events: none;
        }

        .hit-marker.active {
            opacity: 1;
        }

        #ammo-bar {
            width: 200px;
            height: 10px;
            border: 1px solid #00ffff;
            margin-top: 5px;
        }

        #ammo-fill {
            width: 100%;
            height: 100%;
            background: #00ffff;
            box-shadow: 0 0 10px #00ffff;
            transition: width 0.15s linear;
        }

        /* --- Mobile Controls --- */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            display: none; /* Hidden by default, shown on touch */
        }

        @media (pointer: coarse) {
            #mobile-controls {
                display: block;
            }
            h1 { font-size: 2.5rem; }
        }

        .control-zone {
            position: absolute;
            bottom: 40px;
            pointer-events: auto;
            z-index: 15; /* Higher than look zone */
            touch-action: none;
        }

        /* Joystick Base */
        #joystick-zone {
            left: 40px;
            width: 120px;
            height: 120px;
            border: 2px solid #00ffff;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.08);
            opacity: 0.6;
        }

        /* Joystick Thumb */
        #joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: #00ffff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #00ffff;
            pointer-events: none;
        }

        /* Fire Button */
        #fire-btn {
            right: 40px;
            bottom: 60px;
            width: 80px;
            height: 80px;
            border: 2px solid #ff0055;
            border-radius: 50%;
            background: rgba(255, 0, 85, 0.22);
            color: #ff0055;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            opacity: 0.75;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.25);
            z-index: 15;
            user-select: none;
            -webkit-user-select: none;
        }

        #fire-btn:active {
            background: rgba(255, 0, 85, 0.5);
            transform: scale(0.96);
        }

        /* Look Zone (Full Screen Background) */
        #look-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            z-index: 1; /* Lowest interaction layer */
            touch-action: none;
        }
    </style>
</head>
<body>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <div id="game-ui">
        <div class="hud-top">
            <div id="score-display">SCORE: 0000</div>
            <div id="time-display">TIME: 60</div>
        </div>
        <div class="hud-bottom">
            <div id="ammo-text">AMMO: 30 / ∞</div>
            <div id="ammo-bar"><div id="ammo-fill"></div></div>
        </div>
        <div id="crosshair"></div>
        <div id="hit-marker" class="hit-marker"></div>
    </div>

    <div id="mobile-controls">
        <div id="look-zone"></div> <!-- Now covers full screen -->
        <div id="joystick-zone" class="control-zone">
            <div id="joystick-thumb"></div>
        </div>
        <div id="fire-btn" class="control-zone" role="button" aria-label="Fire">FIRE</div>
    </div>

    <div id="start-screen">
        <h1>GRID LOCK</h1>
        <p>MOBILE: LEFT STICK Move • TOUCH ANYWHERE Aim • BTN Fire</p>
        <p>PC: WASD Move • MOUSE Aim • HOLD CLICK Auto-Fire</p>
        <button class="btn" id="init-btn">INITIALIZE</button>
    </div>

    <script>
        // --- Cached DOM ---
        const DOM = {
            fireBtn: null,
            ammoText: null,
            ammoFill: null,
            hitMarker: null,
            startScreen: null,
            initBtn: null,
            mobileControls: null
        };

        // --- Game Constants & State ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let joyVector = { x: 0, y: 0 };
        let isFiring = false; // For auto-fire

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const clock = new THREE.Clock();

        // Sensitivity Settings
        const BASE_SENSITIVITY = 0.005; 

        let isLocked = false;
        let score = 0;
        let timeLeft = 60;
        let gameActive = false;
        let lastShotTime = 0;
        const fireRate = 100; // Faster fire rate for automatic
        let ammo = 30;
        const maxAmmo = 30;
        let isReloading = false;

        // Entities
        let targets = [];
        let debris = [];
        let obstacles = []; // Walls
        let gunGroup;
        let muzzleFlash;

        // Collision Helpers
        const playerBox = new THREE.Box3();
        const wallBox = new THREE.Box3();
        const tempVec = new THREE.Vector3();

        const raycaster = new THREE.Raycaster(); 

        // Colors
        const COLOR_GRID = 0x004444;
        const COLOR_GRID_MAIN = 0x00ffff;
        const COLOR_TARGET_FILL = 0xff6600;
        const COLOR_TARGET_WIRE = 0xffaa00;
        const COLOR_OBSTACLE = 0x003333;
        const COLOR_OBSTACLE_WIRE = 0x008888;

        function init() {
            // cache dom
            DOM.fireBtn = document.getElementById('fire-btn');
            DOM.ammoText = document.getElementById('ammo-text');
            DOM.ammoFill = document.getElementById('ammo-fill');
            DOM.hitMarker = document.getElementById('hit-marker');
            DOM.startScreen = document.getElementById('start-screen');
            DOM.initBtn = document.getElementById('init-btn');
            DOM.mobileControls = document.getElementById('mobile-controls');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';
            camera.position.y = 1.6;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            createEnvironment();
            createGun();
            setupInputs();
            window.addEventListener('resize', onWindowResize);

            updateAmmo();
            animate();
        }

        function createEnvironment() {
            // Floor
            const gridHelper = new THREE.GridHelper(200, 100, COLOR_GRID_MAIN, COLOR_GRID);
            scene.add(gridHelper);

            // Ceiling
            const ceilGrid = new THREE.GridHelper(200, 40, 0x002222, 0x001111);
            ceilGrid.position.y = 20;
            scene.add(ceilGrid);

            createMap();
        }

        function createMap() {
            // Define a Map Area (Size 80x80)
            // Create Boundary Walls
            createWall(0, 10, -40, 80, 20, 2); // Back
            createWall(0, 10, 40, 80, 20, 2);  // Front
            createWall(-40, 10, 0, 2, 20, 80); // Left
            createWall(40, 10, 0, 2, 20, 80);  // Right

            // Random Scatter of Internal Cubes/Walls
            for(let i=0; i<12; i++) {
                const w = 4 + Math.random() * 6;
                const h = 4 + Math.random() * 8;
                const d = 4 + Math.random() * 6;
                
                // Keep away from center (spawn)
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 60;
                    z = (Math.random() - 0.5) * 60;
                } while(Math.sqrt(x*x + z*z) < 10); 

                createWall(x, h/2, z, w, h, d);
            }
        }

        function createWall(x, y, z, w, h, d) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshBasicMaterial({ color: COLOR_OBSTACLE });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            
            // Wireframe edge
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: COLOR_OBSTACLE_WIRE }));
            mesh.add(line);

            scene.add(mesh);
            obstacles.push(mesh); // Add to array for spawn checks
        }

        function createGun() {
            gunGroup = new THREE.Group();

            const wireMat = new THREE.LineBasicMaterial({ color: 0x00ffff });
            const solidMat = new THREE.MeshBasicMaterial({ color: 0x002222 });

            const bodyGeo = new THREE.BoxGeometry(0.2, 0.2, 0.6);
            const bodyEdges = new THREE.EdgesGeometry(bodyGeo);
            const bodyLines = new THREE.LineSegments(bodyEdges, wireMat);
            const bodyFill = new THREE.Mesh(bodyGeo, solidMat);
            bodyFill.scale.set(0.9, 0.9, 0.9);

            const barrelGeo = new THREE.BoxGeometry(0.05, 0.05, 0.4);
            const barrelEdges = new THREE.EdgesGeometry(barrelGeo);
            const barrelLines = new THREE.LineSegments(barrelEdges, wireMat);
            barrelLines.position.z = -0.5;
            barrelLines.position.y = 0.02;

            const scopeGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.2, 16);
            const scopeEdges = new THREE.EdgesGeometry(scopeGeo);
            const scopeLines = new THREE.LineSegments(scopeEdges, new THREE.LineBasicMaterial({ color: 0xff0055 }));
            scopeLines.rotation.x = Math.PI / 2;
            scopeLines.position.y = 0.15;
            scopeLines.position.z = -0.1;

            const flashGeo = new THREE.PlaneGeometry(0.3, 0.3);
            const flashMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0 });
            muzzleFlash = new THREE.Mesh(flashGeo, flashMat);
            muzzleFlash.position.z = -0.8;
            muzzleFlash.rotation.z = Math.random() * Math.PI;

            gunGroup.add(bodyLines);
            gunGroup.add(bodyFill);
            gunGroup.add(barrelLines);
            gunGroup.add(scopeLines);
            gunGroup.add(muzzleFlash);

            gunGroup.position.set(0.25, -0.25, -0.5);
            camera.add(gunGroup);
            scene.add(camera);
        }

        // --- Collision Logic ---

        function checkPlayerCollision() {
            // Assume player is roughly 1 unit wide, 2 units tall
            playerBox.setFromCenterAndSize(camera.position, tempVec.set(1, 2, 1));

            for (let wall of obstacles) {
                if (!wall.geometry.boundingBox) wall.geometry.computeBoundingBox();
                
                wallBox.copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);

                if (playerBox.intersectsBox(wallBox)) return true;
            }
            return false;
        }

        // For spawn point generation (simpler radius check)
        function checkSpawnCollision(pos, radius) {
            const tempBox = new THREE.Box3();
            const center = new THREE.Vector3(pos.x, pos.y, pos.z);
            tempBox.setFromCenterAndSize(center, new THREE.Vector3(radius*2 + 4, radius*2 + 4, radius*2 + 4));

            for (let wall of obstacles) {
                if (!wall.geometry.boundingBox) wall.geometry.computeBoundingBox();
                const wBox = new THREE.Box3();
                wBox.copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);

                if (tempBox.intersectsBox(wBox)) return true;
            }
            return false;
        }

        function spawnTarget() {
            if (targets.length >= 15) return; 

            const size = 1 + Math.random() * 0.5;
            let x, y, z;
            let valid = false;
            let attempts = 0;

            while(!valid && attempts < 20) {
                attempts++;
                x = (Math.random() - 0.5) * 70; 
                z = (Math.random() - 0.5) * 70;
                y = 1 + Math.random() * 4;

                if (Math.sqrt(x*x + z*z) < 5) continue;

                if (!checkSpawnCollision({x,y,z}, size)) {
                    valid = true;
                }
            }

            if (!valid) return; 

            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshBasicMaterial({ color: COLOR_TARGET_FILL, transparent: true, opacity: 0.22 });
            const target = new THREE.Mesh(geometry, material);

            const edges = new THREE.EdgesGeometry(geometry);
            const lineMat = new THREE.LineBasicMaterial({ color: COLOR_TARGET_WIRE });
            const wireframe = new THREE.LineSegments(edges, lineMat);
            target.add(wireframe);

            const coreGeo = new THREE.BoxGeometry(size * 0.4, size * 0.4, size * 0.4);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.set(0, 0, 0);
            target.add(core);

            target.position.set(x, y, z);

            target.userData = {
                id: Math.random(),
                bobSpeed: 1 + Math.random() * 2,
                bobOffset: Math.random() * Math.PI
            };

            scene.add(target);
            targets.push(target);
        }

        function createExplosion(position) {
            const particleCount = 8;
            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: COLOR_TARGET_WIRE, wireframe: true, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);

                mesh.position.copy(position);

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );

                debris.push({ mesh: mesh, velocity: vel, life: 0.8 });
                scene.add(mesh);
            }
        }

        // --- Controls & Input ---
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;
        let lastTouchX = 0;
        let lastTouchY = 0;

        function setupInputs() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            DOM.initBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                startGame();
            });

            // --- PC Mouse Events ---
            document.addEventListener('mousedown', (e) => {
                if (e.target.closest('.control-zone') || e.target.closest('#start-screen')) return;
                
                if (!gameActive && e.target.closest('#start-screen')) {
                    startGame();
                } else if (gameActive && !isLocked && !isMobile()) {
                    document.body.requestPointerLock();
                } else if (gameActive && isLocked) {
                    isFiring = true;
                }
            });
            
            document.addEventListener('mouseup', () => {
                isFiring = false;
            });

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                if (!isLocked) isFiring = false;
            });

            // --- Mobile Events ---
            const joyZone = document.getElementById('joystick-zone');
            const joyThumb = document.getElementById('joystick-thumb');
            const lookZone = document.getElementById('look-zone'); 
            const fireBtn = DOM.fireBtn;

            // FIRE BTN
            const handleFireStart = (e) => {
                e.preventDefault();
                e.stopPropagation();
                try { e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId); } catch (err) {}
                if (gameActive) isFiring = true;
            };
            const handleFireEnd = (e) => {
                isFiring = false;
                try { e.target.releasePointerCapture && e.target.releasePointerCapture(e.pointerId); } catch (err) {}
            };

            fireBtn.addEventListener('pointerdown', handleFireStart, { passive: false });
            fireBtn.addEventListener('pointerup', handleFireEnd);
            fireBtn.addEventListener('pointercancel', handleFireEnd);

            // JOYSTICK
            const handleJoystickPointer = (ev) => {
                ev.preventDefault();
                ev.stopPropagation(); 
                const p = ev;
                if (p.pointerType === 'touch' || p.pointerType === 'pen' || p.pointerType === 'mouse') {
                    handleJoystick({ clientX: p.clientX, clientY: p.clientY }, joyZone, joyThumb);
                }
            };

            joyZone.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                e.stopPropagation(); 
                joyZone.setPointerCapture && joyZone.setPointerCapture(e.pointerId);
                handleJoystickPointer(e);
            }, { passive: false });

            joyZone.addEventListener('pointermove', (e) => {
                e.stopPropagation(); 
                if (e.buttons === 0 && e.pointerType === 'mouse') return;
                handleJoystickPointer(e);
            }, { passive: false });

            joyZone.addEventListener('pointerup', (e) => {
                try { joyZone.releasePointerCapture && joyZone.releasePointerCapture(e.pointerId); } catch (err) {}
                joyVector.x = 0;
                joyVector.y = 0;
                joyThumb.style.transform = `translate(-50%, -50%)`;
            }, { passive: false });

            // LOOK ZONE
            lookZone.addEventListener('pointerdown', (e) => {
                lastTouchX = e.clientX;
                lastTouchY = e.clientY;
            }, { passive: true });

            lookZone.addEventListener('pointermove', (e) => {
                if (e.pointerType === 'mouse' && !e.buttons) return;
                
                const movementX = e.clientX - lastTouchX;
                const movementY = e.clientY - lastTouchY;
                lastTouchX = e.clientX;
                lastTouchY = e.clientY;
                
                handleLook(movementX * 2, movementY * 2);
            }, { passive: true });
        }

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function handleJoystick(touchLike, zone, thumb) {
            const rect = zone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const maxRadius = rect.width / 2;

            let deltaX = touchLike.clientX - centerX;
            let deltaY = touchLike.clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > maxRadius) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxRadius;
                deltaY = Math.sin(angle) * maxRadius;
            }

            thumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

            joyVector.x = deltaX / maxRadius;
            joyVector.y = deltaY / maxRadius;
        }

        function startGame() {
            if (!isMobile()) {
                try { document.body.requestPointerLock(); } catch (err) { /* ignore */ }
            }
            DOM.startScreen.style.display = 'none';
            gameActive = true;
            score = 0;
            timeLeft = 60;
            updateScore();

            targets.forEach(t => scene.remove(t));
            targets = [];

            for (let i = 0; i < 10; i++) spawnTarget();

            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                timeLeft--;
                document.getElementById('time-display').textContent = `TIME: ${timeLeft}`;
                if (timeLeft <= 0) {
                    endGame();
                    clearInterval(timerInterval);
                }
            }, 1000);
        }

        function endGame() {
            gameActive = false;
            isFiring = false;
            try { document.exitPointerLock(); } catch (err) {}
            DOM.startScreen.style.display = 'flex';
            document.querySelector('#start-screen h1').textContent = "SIMULATION COMPLETE";
            document.querySelector('#start-screen p').textContent = `FINAL SCORE: ${score}`;
            DOM.initBtn.textContent = "RESTART";
        }

        function onMouseMove(event) {
            if (!isLocked) return;
            handleLook(event.movementX, event.movementY);
        }

        function handleLook(movementX, movementY) {
            euler.setFromQuaternion(camera.quaternion);

            euler.y -= movementX * BASE_SENSITIVITY;
            euler.x -= movementY * BASE_SENSITIVITY;
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));

            camera.quaternion.setFromEuler(euler);
        }

        function findTargetRoot(obj) {
            while (obj && !targets.includes(obj)) {
                obj = obj.parent;
            }
            return obj || null;
        }

        function shoot() {
            if (!gameActive || isReloading) return;

            if (ammo <= 0) {
                reload();
                return;
            }

            const now = performance.now();
            if (now - lastShotTime < fireRate) return;
            lastShotTime = now;

            camera.rotation.x += 0.02;
            gunGroup.position.z += 0.2;

            ammo = Math.max(0, ammo - 1);
            updateAmmo();

            muzzleFlash.material.opacity = 1;
            muzzleFlash.rotation.z = Math.random() * Math.PI;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = raycaster.intersectObjects(targets, true);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                const targetRoot = findTargetRoot(hit) || hit;
                if (targetRoot) {
                    createExplosion(targetRoot.position);
                    scene.remove(targetRoot);
                    targets = targets.filter(t => t !== targetRoot);

                    score += 100;
                    updateScore();

                    DOM.hitMarker.classList.add('active');
                    clearTimeout(DOM._hitTimeout);
                    DOM._hitTimeout = setTimeout(() => {
                        DOM.hitMarker.classList.remove('active');
                    }, 120);

                    spawnTarget();
                }
            }
        }

        function reload() {
            if (isReloading) return;
            isReloading = true;
            isFiring = false; 
            DOM.ammoText.textContent = "RELOADING...";
            gunGroup.rotation.x = -0.5;

            setTimeout(() => {
                ammo = maxAmmo;
                updateAmmo();
                isReloading = false;
                gunGroup.rotation.x = 0;
            }, 1500);
        }

        function updateScore() {
            document.getElementById('score-display').textContent = `SCORE: ${score.toString().padStart(4, '0')}`;
        }

        function updateAmmo() {
            DOM.ammoText.textContent = `AMMO: ${ammo} / ∞`;
            DOM.ammoFill.style.width = `${(ammo / maxAmmo) * 100}%`;
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = true; break;
                case 'KeyR': reload(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (isFiring) shoot();

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            let inputZ = Number(moveBackward) - Number(moveForward);
            let inputX = Number(moveRight) - Number(moveLeft);

            if (Math.abs(joyVector.y) > 0.12) inputZ += joyVector.y;
            if (Math.abs(joyVector.x) > 0.12) inputX += joyVector.x;

            direction.z = inputZ;
            direction.x = inputX;

            if (direction.lengthSq() > 0) {
                direction.normalize();
            }

            if (inputZ !== 0) velocity.z -= direction.z * 100.0 * delta;
            if (inputX !== 0) velocity.x -= direction.x * 100.0 * delta;

            if (isLocked || inputZ !== 0 || inputX !== 0) {
                // --- NEW Collision Handling ---
                // Calculate desired move in World Space
                const moveVec = new THREE.Vector3(-velocity.x * delta, 0, -velocity.z * delta);
                moveVec.applyQuaternion(camera.quaternion);
                moveVec.y = 0; // Keep movement flat

                // Try X Movement
                camera.position.x += moveVec.x;
                if (checkPlayerCollision()) {
                    camera.position.x -= moveVec.x; // Revert X
                    velocity.x = 0; // Kill momentum on hit
                }

                // Try Z Movement
                camera.position.z += moveVec.z;
                if (checkPlayerCollision()) {
                    camera.position.z -= moveVec.z; // Revert Z
                    velocity.z = 0; // Kill momentum on hit
                }
            }

            camera.position.y = 1.6;

            gunGroup.position.z += (-0.5 - gunGroup.position.z) * 10 * delta;
            gunGroup.rotation.y = -velocity.x * 0.005;
            gunGroup.rotation.x = -velocity.z * 0.005;

            if (muzzleFlash.material.opacity > 0) {
                muzzleFlash.material.opacity = Math.max(0, muzzleFlash.material.opacity - 10 * delta);
            }

            const now = clock.getElapsedTime();
            targets.forEach(target => {
                target.position.y += Math.sin(now * target.userData.bobSpeed + target.userData.bobOffset) * 0.02;
                target.rotation.y += 1 * delta;
                target.rotation.x += 0.5 * delta;
            });

            if (gameActive && targets.length < 8) {
                if (Math.random() < 0.1) spawnTarget();
            }

            for (let i = debris.length - 1; i >= 0; i--) {
                const p = debris[i];
                p.mesh.position.addScaledVector(p.velocity, delta);
                p.mesh.rotation.x += p.velocity.z * delta;
                p.life -= delta;
                p.mesh.material.opacity = Math.max(0, p.life);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    debris.splice(i, 1);
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
